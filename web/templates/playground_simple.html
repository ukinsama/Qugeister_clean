<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum AI Playground - Simple</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 300px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            overflow-y: auto;
        }
        
        .main-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px;
        }
        
        .sidebar-title {
            font-size: 1.2em;
            font-weight: bold;
            color: #2196F3;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #2196F3;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .slider {
            width: 100%;
            margin: 10px 0;
        }
        
        .btn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .btn:hover {
            background: #1976D2;
        }
        
        .btn-success {
            background: #4CAF50;
        }
        
        .btn-success:hover {
            background: #45a049;
        }
        
        .btn-warning {
            background: #FF9800;
        }
        
        .btn-warning:hover {
            background: #F57C00;
        }
        
        .config-display {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .notification.success {
            background: #4CAF50;
        }
        
        .notification.error {
            background: #f44336;
        }
        
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .test-output {
            background: #263238;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-title">🔬 Quantum Configuration</div>
            
            <div class="control-group">
                <label>量子ビット数: <span id="qubit-count">8</span></label>
                <input type="range" class="slider" id="qubit-slider" 
                       min="4" max="16" value="8" 
                       oninput="updateQubits(this.value)">
            </div>
            
            <div class="control-group">
                <label>層数: <span id="layer-count">3</span></label>
                <input type="range" class="slider" id="layer-slider" 
                       min="1" max="8" value="3" 
                       oninput="updateLayers(this.value)">
            </div>
            
            <div class="control-group">
                <label>エンタングルメント:</label>
                <select id="entanglement-select" onchange="updateEntanglement()">
                    <option value="linear">Linear</option>
                    <option value="circular">Circular</option>
                    <option value="full">Full</option>
                </select>
            </div>
            
            <div class="config-display" id="config-display">
                Config will appear here...
            </div>
            
            <div class="sidebar-title">🔗 ワークフロー (双方向)</div>
            
            <div class="control-group">
                <button class="btn" style="width: 100%; margin-bottom: 8px;" onclick="exportToComposer()">
                    🌐 IBM Quantum Composerへ →
                </button>
                <button class="btn btn-success" style="width: 100%;" onclick="importFromComposer()">
                    📥 ← Composerから設定インポート
                </button>
            </div>
            
            <div class="sidebar-title">🐛 デバッグ</div>
            
            <div class="control-group">
                <button class="btn btn-warning" style="width: 100%;" onclick="runDebugTests()">
                    🐛 デバッグテスト実行
                </button>
            </div>
        </div>
        
        <div class="main-content">
            <h1>🌌 Quantum AI Playground (Simple)</h1>
            <p>量子回路設定とIBM Quantum Composerとの双方向データフロー</p>
            
            <div id="current-config" class="config-display">
                現在の設定が表示されます...
            </div>
            
            <div class="test-output" id="test-output" style="display: none;"></div>
        </div>
    </div>

    <script>
        // グローバル設定
        let currentConfig = {
            qubits: 8,
            layers: 3,
            entanglement: 'linear'
        };

        // 設定を更新する関数群
        function updateQubits(value) {
            currentConfig.qubits = parseInt(value);
            document.getElementById('qubit-count').textContent = value;
            updateConfigDisplay();
        }

        function updateLayers(value) {
            currentConfig.layers = parseInt(value);
            document.getElementById('layer-count').textContent = value;
            updateConfigDisplay();
        }

        function updateEntanglement() {
            const select = document.getElementById('entanglement-select');
            currentConfig.entanglement = select.value;
            updateConfigDisplay();
        }

        function updateConfigDisplay() {
            const configDiv = document.getElementById('config-display');
            configDiv.innerHTML = `
                <strong>Current Config:</strong><br>
                Qubits: ${currentConfig.qubits}<br>
                Layers: ${currentConfig.layers}<br>
                Entanglement: ${currentConfig.entanglement}
            `;

            const mainConfigDiv = document.getElementById('current-config');
            mainConfigDiv.innerHTML = `
                <strong>量子回路設定:</strong><br>
                🔬 量子ビット数: ${currentConfig.qubits}<br>
                📚 層数: ${currentConfig.layers}<br>
                🔗 エンタングルメント: ${currentConfig.entanglement}<br>
                📊 推定パラメータ数: ${currentConfig.qubits * currentConfig.layers * 2}
            `;
        }

        // QASM生成関数
        function generateOpenQASM(qubits, layers, entanglement) {
            let qasm = `OPENQASM 2.0;
include "qelib1.inc";

qreg q[${qubits}];
creg c[${qubits}];

// Quantum AI Circuit - ${layers} layers, ${entanglement} entanglement
`;

            for (let layer = 0; layer < layers; layer++) {
                qasm += `\\n// Layer ${layer + 1}\\n`;
                
                // 回転ゲート
                for (let i = 0; i < qubits; i++) {
                    qasm += `ry(theta_${layer}_${i}) q[${i}];\\n`;
                    qasm += `rz(phi_${layer}_${i}) q[${i}];\\n`;
                }
                
                // エンタングルメント
                if (entanglement === 'linear') {
                    for (let i = 0; i < qubits - 1; i++) {
                        qasm += `cx q[${i}], q[${i+1}];\\n`;
                    }
                } else if (entanglement === 'circular') {
                    for (let i = 0; i < qubits - 1; i++) {
                        qasm += `cx q[${i}], q[${i+1}];\\n`;
                    }
                    qasm += `cx q[${qubits-1}], q[0];\\n`;
                } else if (entanglement === 'full') {
                    for (let i = 0; i < qubits; i++) {
                        for (let j = i + 1; j < qubits; j++) {
                            qasm += `cz q[${i}], q[${j}];\\n`;
                        }
                    }
                }
                qasm += '\\n';
            }

            // 測定
            qasm += '// Measurement\\n';
            for (let i = 0; i < qubits; i++) {
                qasm += `measure q[${i}] -> c[${i}];\\n`;
            }

            return qasm;
        }

        // QASMパーシング関数
        function parseQASMToConfig(qasmCode) {
            const config = {
                qubits: 8,
                layers: 3,
                entanglement: 'linear'
            };
            
            try {
                if (!qasmCode || typeof qasmCode !== 'string') {
                    throw new Error('Invalid QASM code provided');
                }
                
                // 量子ビット数を抽出
                const qubitMatch = qasmCode.match(/qreg\\s+q\\[(\\d+)\\]/);
                if (qubitMatch) {
                    const qubits = parseInt(qubitMatch[1]);
                    if (qubits > 0 && qubits <= 32) {
                        config.qubits = qubits;
                    }
                }
                
                // 層数を推定
                const rotationGates = qasmCode.match(/r[xyz]\\(/g);
                if (rotationGates && rotationGates.length > 0) {
                    const totalRotations = rotationGates.length;
                    const estimatedLayers = Math.ceil(totalRotations / (config.qubits * 2));
                    config.layers = Math.max(1, Math.min(estimatedLayers, 10));
                }
                
                // エンタングルメントタイプを判定
                const cxGates = qasmCode.match(/cx\\s+q\\[\\d+\\],\\s*q\\[\\d+\\]/g) || [];
                const czGates = qasmCode.match(/cz\\s+q\\[\\d+\\],\\s*q\\[\\d+\\]/g) || [];
                
                if (czGates.length > cxGates.length) {
                    config.entanglement = 'full';
                } else if (cxGates.length > 0) {
                    const circularPattern = new RegExp(`cx\\\\s+q\\\\[${config.qubits-1}\\\\],\\\\s*q\\\\[0\\\\]`);
                    if (circularPattern.test(qasmCode)) {
                        config.entanglement = 'circular';
                    } else {
                        config.entanglement = 'linear';
                    }
                }
                
                return config;
                
            } catch (error) {
                throw new Error(`QASM解析エラー: ${error.message}`);
            }
        }

        // 設定を適用
        function applyConfig(config) {
            // スライダーを更新
            document.getElementById('qubit-slider').value = config.qubits;
            document.getElementById('layer-slider').value = config.layers;
            document.getElementById('entanglement-select').value = config.entanglement;
            
            // グローバル設定を更新
            currentConfig = {...config};
            
            // 表示を更新
            updateQubits(config.qubits);
            updateLayers(config.layers);
            updateEntanglement();
        }

        // 通知表示
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => notification.remove(), type === 'error' ? 5000 : 3000);
        }

        // ログ出力
        function log(message, type = 'info') {
            const output = document.getElementById('test-output');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '❌' : type === 'success' ? '✅' : 'ℹ️';
            output.textContent += `[${timestamp}] ${prefix} ${message}\\n`;
            output.scrollTop = output.scrollHeight;
            output.style.display = 'block';
        }

        // エクスポート機能
        function exportToComposer() {
            const qasm = generateOpenQASM(currentConfig.qubits, currentConfig.layers, currentConfig.entanglement);
            
            const newWindow = window.open("", "_blank");
            newWindow.document.write(`
                <html>
                <head>
                    <title>IBM Quantum Composer Export</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        .qasm-content { background: #f5f5f5; padding: 20px; border-radius: 5px; white-space: pre-wrap; }
                        button { background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 10px 5px; }
                    </style>
                </head>
                <body>
                    <h1>🔬 IBM Quantum Composer Export</h1>
                    <p>以下のQASMコードをIBM Quantum Composerで使用してください。</p>
                    
                    <button onclick="copyToClipboard()">📋 コピー</button>
                    <button onclick="sendBackToPlayground()">🔄 結果を戻す</button>
                    
                    <div class="qasm-content" id="qasm-content">${qasm}</div>
                    
                    <script>
                        function copyToClipboard() {
                            const content = document.getElementById('qasm-content').textContent;
                            navigator.clipboard.writeText(content).then(() => {
                                alert('QASMコードがクリップボードにコピーされました！');
                            });
                        }
                        
                        function sendBackToPlayground() {
                            const qasmCode = prompt('編集したQASMコードを貼り付けてください:', '');
                            if (qasmCode && qasmCode.trim()) {
                                if (window.opener && !window.opener.closed) {
                                    window.opener.postMessage({
                                        type: 'COMPOSER_QASM_IMPORT',
                                        qasm: qasmCode
                                    }, '*');
                                    alert('データを送信しました！');
                                    window.close();
                                } else {
                                    alert('Playgroundウィンドウが見つかりません。');
                                }
                            }
                        }
                    </scr` + `ipt>
                </body>
                </html>
            `);
            
            showNotification('Composerウィンドウを開きました');
        }

        // インポート機能
        function importFromComposer() {
            const qasmCode = prompt('IBM Quantum ComposerからQASMコードを貼り付けてください:', '');
            if (qasmCode && qasmCode.trim()) {
                try {
                    const config = parseQASMToConfig(qasmCode);
                    applyConfig(config);
                    showNotification('設定をインポートしました！');
                } catch (error) {
                    showNotification('インポートエラー: ' + error.message, 'error');
                }
            }
        }

        // デバッグテスト
        function runDebugTests() {
            document.getElementById('test-output').textContent = '';
            log('=== デバッグテスト開始 ===');
            
            try {
                // 基本機能テスト
                log('1. 基本機能テスト');
                const qasm = generateOpenQASM(4, 2, 'linear');
                log(`QASM生成成功 (${qasm.length}文字)`, 'success');
                
                // パーシングテスト
                log('2. QASMパーシングテスト');
                const config = parseQASMToConfig(qasm);
                log(`パーシング成功: ${JSON.stringify(config)}`, 'success');
                
                // UI要素テスト
                log('3. UI要素テスト');
                const elements = ['qubit-slider', 'layer-slider', 'entanglement-select'];
                elements.forEach(id => {
                    const element = document.getElementById(id);
                    log(`${id}: ${element ? '✅' : '❌'}`);
                });
                
                // エラーハンドリングテスト
                log('4. エラーハンドリングテスト');
                try {
                    parseQASMToConfig('invalid');
                } catch (e) {
                    log('エラーハンドリング正常', 'success');
                }
                
                log('=== 全テスト完了 ===', 'success');
                showNotification('デバッグテストが完了しました！');
                
            } catch (error) {
                log(`テストエラー: ${error.message}`, 'error');
                showNotification('デバッグテストでエラーが発生しました', 'error');
            }
        }

        // メッセージリスナー
        window.addEventListener('message', (event) => {
            if (event.data.type === 'COMPOSER_QASM_IMPORT') {
                try {
                    const config = parseQASMToConfig(event.data.qasm);
                    applyConfig(config);
                    showNotification('Composerから設定をインポートしました！');
                } catch (error) {
                    showNotification('インポートエラー: ' + error.message, 'error');
                }
            }
        });

        // 初期化
        window.onload = function() {
            updateConfigDisplay();
            showNotification('Quantum AI Playground が読み込まれました！');
        };
    </script>
</body>
</html>