<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debug Test - Bidirectional Data Flow</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 10px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #1976D2;
        }
        .error {
            background: #f44336;
        }
        .success {
            background: #4CAF50;
        }
        #output {
            background: #263238;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>ğŸ› Quantum Playground Debug Test</h1>
    
    <div class="test-section">
        <h2>åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</h2>
        <button onclick="testBasicFunctions()">åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="testQASMParsing()">QASMãƒ‘ãƒ¼ã‚·ãƒ³ã‚°ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="testBidirectionalFlow()">åŒæ–¹å‘ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="clearOutput()">å‡ºåŠ›ã‚¯ãƒªã‚¢</button>
    </div>

    <div class="test-section">
        <h2>æ‰‹å‹•ãƒ†ã‚¹ãƒˆ</h2>
        <button onclick="testManualImport()">æ‰‹å‹•ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ†ã‚¹ãƒˆ</button>
        <button onclick="testExportWindow()">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ†ã‚¹ãƒˆ</button>
    </div>

    <div class="test-section">
        <h2>å‡ºåŠ›</h2>
        <div id="output"></div>
    </div>

    <script>
        function log(message, type = 'info') {
            const output = document.getElementById('output');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : 'â„¹ï¸';
            output.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            output.scrollTop = output.scrollHeight;
        }

        function clearOutput() {
            document.getElementById('output').textContent = '';
        }

        // åŸºæœ¬çš„ãªQASMç”Ÿæˆé–¢æ•°
        function generateTestQASM(qubits = 4, layers = 2, entanglement = 'linear') {
            let qasm = `OPENQASM 2.0;
include "qelib1.inc";

qreg q[${qubits}];
creg c[${qubits}];

// Quantum circuit with ${layers} layers
`;

            for (let layer = 0; layer < layers; layer++) {
                qasm += `// Layer ${layer + 1}\n`;
                for (let i = 0; i < qubits; i++) {
                    qasm += `ry(${(Math.random() * Math.PI).toFixed(3)}) q[${i}];\n`;
                }
                
                // ã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆ
                if (entanglement === 'linear') {
                    for (let i = 0; i < qubits - 1; i++) {
                        qasm += `cx q[${i}], q[${i+1}];\n`;
                    }
                } else if (entanglement === 'circular') {
                    for (let i = 0; i < qubits - 1; i++) {
                        qasm += `cx q[${i}], q[${i+1}];\n`;
                    }
                    qasm += `cx q[${qubits-1}], q[0];\n`;
                } else if (entanglement === 'full') {
                    for (let i = 0; i < qubits; i++) {
                        for (let j = i + 1; j < qubits; j++) {
                            qasm += `cz q[${i}], q[${j}];\n`;
                        }
                    }
                }
                qasm += '\n';
            }

            // æ¸¬å®š
            for (let i = 0; i < qubits; i++) {
                qasm += `measure q[${i}] -> c[${i}];\n`;
            }

            return qasm;
        }

        // QASMãƒ‘ãƒ¼ã‚·ãƒ³ã‚°é–¢æ•°
        function parseQASMToConfig(qasmCode) {
            const config = {
                qubits: 8,
                layers: 3,
                entanglement: 'linear'
            };
            
            try {
                if (!qasmCode || typeof qasmCode !== 'string') {
                    throw new Error('Invalid QASM code provided');
                }
                
                // é‡å­ãƒ“ãƒƒãƒˆæ•°ã‚’æŠ½å‡º
                const qubitMatch = qasmCode.match(/qreg\s+q\[(\d+)\]/);
                if (qubitMatch) {
                    const qubits = parseInt(qubitMatch[1]);
                    if (qubits > 0 && qubits <= 32) {
                        config.qubits = qubits;
                    }
                }
                
                // å±¤æ•°ã‚’æ¨å®š
                const rotationGates = qasmCode.match(/r[xyz]\(/g);
                if (rotationGates && rotationGates.length > 0) {
                    const totalRotations = rotationGates.length;
                    const estimatedLayers = Math.ceil(totalRotations / config.qubits);
                    config.layers = Math.max(1, Math.min(estimatedLayers, 10));
                }
                
                // ã‚¨ãƒ³ã‚¿ãƒ³ã‚°ãƒ«ãƒ¡ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
                const cxGates = qasmCode.match(/cx\s+q\[\d+\],\s*q\[\d+\]/g) || [];
                const czGates = qasmCode.match(/cz\s+q\[\d+\],\s*q\[\d+\]/g) || [];
                
                if (czGates.length > cxGates.length) {
                    config.entanglement = 'full';
                } else if (cxGates.length > 0) {
                    const circularPattern = new RegExp(`cx\\s+q\\[${config.qubits-1}\\],\\s*q\\[0\\]`);
                    if (circularPattern.test(qasmCode)) {
                        config.entanglement = 'circular';
                    } else {
                        config.entanglement = 'linear';
                    }
                }
                
                return config;
                
            } catch (error) {
                throw new Error(`QASMè§£æã‚¨ãƒ©ãƒ¼: ${error.message}`);
            }
        }

        function testBasicFunctions() {
            log('=== åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆé–‹å§‹ ===');
            
            try {
                // QASMç”Ÿæˆãƒ†ã‚¹ãƒˆ
                const qasm = generateTestQASM(6, 3, 'circular');
                log(`QASMç”ŸæˆæˆåŠŸ: ${qasm.length}æ–‡å­—`, 'success');
                log(`å…ˆé ­200æ–‡å­—: ${qasm.substring(0, 200)}...`);
                
                // QASMãƒ‘ãƒ¼ã‚·ãƒ³ã‚°ãƒ†ã‚¹ãƒˆ
                const config = parseQASMToConfig(qasm);
                log(`QASMè§£ææˆåŠŸ: ${JSON.stringify(config)}`, 'success');
                
                log('åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
                
            } catch (error) {
                log(`åŸºæœ¬æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
            }
        }

        function testQASMParsing() {
            log('=== QASMãƒ‘ãƒ¼ã‚·ãƒ³ã‚°ãƒ†ã‚¹ãƒˆé–‹å§‹ ===');
            
            const testCases = [
                {
                    name: 'Simple 4-qubit',
                    qasm: `OPENQASM 2.0;
include "qelib1.inc";
qreg q[4];
creg c[4];
ry(0.5) q[0];
cx q[0], q[1];
measure q[0] -> c[0];`
                },
                {
                    name: 'Circular 6-qubit',
                    qasm: `OPENQASM 2.0;
include "qelib1.inc";
qreg q[6];
creg c[6];
ry(0.5) q[0];
cx q[0], q[1];
cx q[5], q[0];
measure q[0] -> c[0];`
                },
                {
                    name: 'Full 3-qubit',
                    qasm: `OPENQASM 2.0;
include "qelib1.inc";
qreg q[3];
creg c[3];
cz q[0], q[1];
cz q[0], q[2];
cz q[1], q[2];
measure q[0] -> c[0];`
                }
            ];

            testCases.forEach((test, index) => {
                try {
                    const result = parseQASMToConfig(test.qasm);
                    log(`ãƒ†ã‚¹ãƒˆ${index + 1} (${test.name}): ${JSON.stringify(result)}`, 'success');
                } catch (error) {
                    log(`ãƒ†ã‚¹ãƒˆ${index + 1} (${test.name}) ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            });

            log('QASMãƒ‘ãƒ¼ã‚·ãƒ³ã‚°ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
        }

        function testBidirectionalFlow() {
            log('=== åŒæ–¹å‘ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆé–‹å§‹ ===');
            
            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
            window.addEventListener('message', (event) => {
                if (event.data.type === 'COMPOSER_QASM_IMPORT') {
                    log(`ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å—ä¿¡: ${event.data.qasm.substring(0, 100)}...`, 'success');
                    try {
                        const config = parseQASMToConfig(event.data.qasm);
                        log(`è¨­å®šãƒ‘ãƒ¼ã‚¹æˆåŠŸ: ${JSON.stringify(config)}`, 'success');
                    } catch (error) {
                        log(`è¨­å®šãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    }
                }
            });

            // ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡
            const testQASM = generateTestQASM(5, 2, 'linear');
            const testMessage = {
                type: 'COMPOSER_QASM_IMPORT',
                qasm: testQASM
            };

            log('ãƒ†ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ä¸­...');
            window.postMessage(testMessage, '*');

            log('åŒæ–¹å‘ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆå®Œäº†', 'success');
        }

        function testManualImport() {
            const qasmCode = prompt('QASMã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', 
                `OPENQASM 2.0;
include "qelib1.inc";
qreg q[8];
creg c[8];
ry(0.5) q[0];
cx q[0], q[1];
measure q[0] -> c[0];`);
            
            if (qasmCode) {
                try {
                    const config = parseQASMToConfig(qasmCode);
                    log(`æ‰‹å‹•ã‚¤ãƒ³ãƒãƒ¼ãƒˆæˆåŠŸ: ${JSON.stringify(config)}`, 'success');
                } catch (error) {
                    log(`æ‰‹å‹•ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
            }
        }

        function testExportWindow() {
            log('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ†ã‚¹ãƒˆé–‹å§‹');
            
            const qasm = generateTestQASM(4, 2, 'linear');
            const newWindow = window.open("", "_blank");
            
            if (newWindow) {
                newWindow.document.write(`
                    <html>
                    <head><title>Test Export Window</title></head>
                    <body>
                        <h1>ãƒ†ã‚¹ãƒˆã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦</h1>
                        <pre>${qasm}</pre>
                        <button onclick="sendBack()">çµæœã‚’æˆ»ã™</button>
                        <script>
                            function sendBack() {
                                if (window.opener) {
                                    window.opener.postMessage({
                                        type: 'COMPOSER_QASM_IMPORT',
                                        qasm: '${qasm.replace(/'/g, "\\'")}'
                                    }, '*');
                                    alert('ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã—ãŸ');
                                    window.close();
                                }
                            }
                        </script>
                    </body>
                    </html>
                `);
                log('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ãã¾ã—ãŸ', 'success');
            } else {
                log('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‹ã‘ã¾ã›ã‚“ã§ã—ãŸ', 'error');
            }
        }

        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã®åˆæœŸåŒ–
        window.onload = function() {
            log('ãƒ‡ãƒãƒƒã‚°ãƒšãƒ¼ã‚¸ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ', 'success');
            log('å„ç¨®ãƒ†ã‚¹ãƒˆãƒœã‚¿ãƒ³ã‚’ä½¿ç”¨ã—ã¦ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
        };
    </script>
</body>
</html>