<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Battle System - 3 Step Designer</title>
    <!-- <link rel="stylesheet" href="styles.css"> 外部CSSファイル不要 -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* ステップナビゲーション */
        .step-navigation {
            display: flex;
            justify-content: center;
            margin-bottom: 40px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        }

        .step-item {
            display: flex;
            align-items: center;
            margin: 0 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .step-number {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #ddd;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
            transition: all 0.3s ease;
        }

        .step-item.active .step-number {
            background: #667eea;
            transform: scale(1.2);
        }

        .step-item.completed .step-number {
            background: #4CAF50;
        }

        .step-label {
            font-weight: 500;
            color: #999;
            transition: color 0.3s ease;
        }

        .step-item.active .step-label {
            color: #667eea;
            font-weight: bold;
        }

        .step-item.completed .step-label {
            color: #4CAF50;
        }

        .step-connector {
            width: 60px;
            height: 2px;
            background: #ddd;
            margin: 0 10px;
        }

        .step-connector.completed {
            background: #4CAF50;
        }

        /* ステップコンテンツ */
        .step-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .step-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ステップ1: 学習方法選択 */
        .learning-method-container {
            display: flex;
            flex-direction: row;
            gap: 30px;
            max-width: 800px;
            margin: 0 auto;
        }

        .method-card {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
        }

        .method-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }

        .method-card.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #f5f7ff 0%, #e8ecff 100%);
        }

        .method-icon {
            font-size: 3em;
            margin-bottom: 15px;
            text-align: center;
        }

        .method-title {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 15px;
            text-align: center;
        }

        .method-description {
            color: #666;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .method-features {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .feature-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            color: #555;
        }

        .feature-icon {
            color: #4CAF50;
            margin-right: 8px;
        }

        /* ステップ2: モジュール設計 (Jupyter Notebook スタイル) */
        .module-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 30px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        .module-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }

        .module-card:hover {
            transform: translateY(-5px);
        }

        .module-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 12px;
            border-bottom: 2px solid #e9ecef;
        }

        .module-icon {
            font-size: 1.5em;
        }

        /* Jupyter Notebook スタイル */
        .notebook-cell {
            background: white;
            border-left: 4px solid #4CAF50;
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .cell-number {
            color: #888;
            font-family: monospace;
            margin-bottom: 10px;
        }

        .run-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
            transition: background 0.3s ease;
        }

        .run-button:hover {
            background: #45a049;
        }

        .output-area {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-family: monospace;
            white-space: pre-wrap;
            display: none;
        }

        .module-selector {
            margin-top: 15px;
        }

        .selector-title {
            font-weight: 500;
            color: #666;
            margin-bottom: 10px;
        }

        .quantum-config {
            margin: 15px 0;
        }

        .config-item {
            margin: 15px 0;
        }

        .config-label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
        }

        /* ステップ3: ハイパーパラメータ設定 */
        .hyperparameter-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .param-section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .param-section-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .param-grid {
            display: flex;
            flex-direction: column;
            gap: 25px;
            max-width: 800px;
            margin: 0 auto;
        }

        .param-item {
            display: flex;
            flex-direction: column;
        }

        .param-label {
            font-weight: 500;
            color: #555;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .param-input {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .param-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 5px;
            background: #e0e0e0;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        .value-display {
            min-width: 60px;
            text-align: center;
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        /* ボタン */
        .button-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #666;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-success {
            background: #4CAF50;
            color: white;
        }

        .btn-success:hover {
            background: #45a049;
        }

        /* コード出力 */
        .code-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 25px;
            border-radius: 10px;
            margin-top: 30px;
            font-family: 'Consolas', 'Monaco', monospace;
            overflow-x: auto;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
        }

        .code-title {
            color: #4CAF50;
            font-weight: bold;
        }

        .copy-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        /* モジュール選択ボタン */
        .option-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .option-button {
            padding: 12px;
            background: #f0f0f0;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .option-button:hover {
            background: #e8ecff;
            border-color: #667eea;
        }

        .option-button.selected {
            background: #667eea;
            color: white;
            border-color: #5a67d8;
        }

        /* 修正された配置ボード */
        .placement-board {
            display: grid;
            grid-template-columns: repeat(6, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 2px;
            margin: 20px auto;
            background: #444;
            padding: 10px;
            border-radius: 10px;
            width: fit-content;
            position: relative;
        }

        .board-cell {
            background: #f0f0f0;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .board-cell:hover {
            background: #e0e0e0;
        }

        /* 敵エリアのホバー効果を無効化 */
        .board-cell.player-b-good:hover,
        .board-cell.player-b-bad:hover {
            background: #bdbdbd;
        }
        .board-cell.player-b-bad:hover {
            background: #9e9e9e;
        }

        /* プレイヤー別の駒色分け */
        .board-cell.player-a-good { 
            background: #a5d6a7; 
            color: #2e7d32;
        }
        .board-cell.player-a-bad { 
            background: #ef9a9a; 
            color: #c62828;
        }
        .board-cell.player-b-unknown { 
            background: #bdbdbd; 
            color: #616161;
            cursor: not-allowed;
            font-weight: bold;
        }

        /* 配置可能エリアのハイライト */
        .board-cell.player-a-area {
            border: 2px dashed #4caf50;
        }
        .board-cell.player-b-area {
            border: 2px dashed #2196f3;
        }

        /* 脱出口の表示 */
        .board-cell.escape-a {
            background: rgba(76, 175, 80, 0.3);
        }
        .board-cell.escape-b {
            background: rgba(33, 150, 243, 0.3);
        }

        .board-legend {
            text-align: center;
            margin-top: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .legend-item {
            display: inline-block;
            margin: 0 10px;
            padding: 3px 8px;
            border-radius: 3px;
        }

        /* モジュール説明欄のスタイル */
        .module-description {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .module-description h5 {
            color: #495057;
            margin: 0 0 10px 0;
            font-size: 1.1em;
            font-weight: 600;
        }

        .module-description textarea {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.9em;
            line-height: 1.4;
            resize: vertical;
            background: white;
            box-sizing: border-box;
        }

        .module-description textarea:focus {
            border-color: #007bff;
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        .module-description .description-hint {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
            font-style: italic;
        }

        /* Q値マップ説明の切り替え */
        .description-variant {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }
        
        .description-variant.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .qmap-output {
            margin-top: 10px;
        }
        
        .qmap-output h4 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .qmap-output pre {
            font-size: 11px;
            line-height: 1.4;
            color: #2c3e50;
        }

        /* 説明欄の折りたたみ機能 */
        .description-toggle {
            background: none;
            border: none;
            color: #007bff;
            cursor: pointer;
            font-size: 0.9em;
            margin-top: 10px;
            text-decoration: underline;
        }

        .description-toggle:hover {
            color: #0056b3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Quantum Battle System Designer</h1>
            <p>3ステップでAI戦略を設計・学習・実行</p>
        </div>

        <!-- ステップナビゲーション -->
        <div class="step-navigation">
            <div class="step-item active" id="nav-step1" onclick="showStep(1)">
                <div class="step-number">1</div>
                <div class="step-label">学習方法選択</div>
            </div>
            <div class="step-connector" id="connector1"></div>
            <div class="step-item" id="nav-step2" onclick="showStep(2)">
                <div class="step-number">2</div>
                <div class="step-label">モジュール設計</div>
            </div>
            <div class="step-connector" id="connector2"></div>
            <div class="step-item" id="nav-step3" onclick="showStep(3)">
                <div class="step-number">3</div>
                <div class="step-label">パラメータ設定</div>
            </div>
        </div>

        <!-- ステップ1: 学習方法選択 -->
        <div class="step-content active" id="step1">
            <div class="learning-method-container">
                <div class="method-card" id="rl-card" onclick="selectLearningMethod('reinforcement')">
                    <div class="method-icon">🎮</div>
                    <div class="method-title">強化学習</div>
                    <div class="method-description">
                        エージェントが環境と相互作用しながら、試行錯誤を通じて最適な戦略を学習します。
                        実際に対戦を繰り返し、報酬を最大化する行動を習得します。
                    </div>
                    <div class="method-features">
                        <div class="feature-item">
                            <span class="feature-icon">✓</span>
                            自己対戦による学習
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">✓</span>
                            Q学習
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">✓</span>
                            探索と活用のバランス
                        </div>
                        <div class="feature-item">
                            <span class="feature-icon">✓</span>
                            動的な戦略の獲得
                        </div>
                    </div>
                </div>

            </div>

            <div class="button-container">
                <button class="btn btn-primary" onclick="proceedToStep2()">次へ進む →</button>
            </div>
        </div>

        <!-- ステップ2: モジュール設計 (Jupyter Notebook Style) -->
        <div class="step-content" id="step2">
            <div class="module-grid">
                <!-- モジュール1: 初期配置 -->
                <div class="module-card">
                    <div class="module-title">
                        <span class="module-icon">♟️</span>
                        モジュール1: 初期配置戦略
                    </div>
                    
                    <div class="notebook-cell">
                        <div class="cell-number">In [1]:</div>
                        <p>駒の初期配置を設定します。クリックして配置を変更できます。</p>
                        
                        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4>🎯 ガイスターのルール</h4>
                            <ul style="margin-left: 20px; margin-top: 10px;">
                                <li><strong>各プレイヤー8駒</strong>: 善玉4個 + 悪玉4個</li>
                                <li><strong>自分の駒のみ配置可能</strong>: 下側2行の中央4列に配置</li>
                                <li><strong>⚠️ 重要</strong>: 相手の駒配置は見えません（未知）</li>
                                <li><strong>脱出口</strong>: 相手陣地の角（薄い色のセル）</li>
                            </ul>
                        </div>

                        <div class="placement-board" id="placementBoard"></div>
                        
                        <div class="board-legend">
                            <div class="legend-item" style="background: #a5d6a7;">A善玉（編集可能）</div>
                            <div class="legend-item" style="background: #ef9a9a;">A悪玉（編集可能）</div>
                            <div class="legend-item" style="background: #bdbdbd; color: #616161; font-weight: bold;">相手駒?（未知・編集不可）</div>
                            <div class="legend-item" style="background: rgba(76, 175, 80, 0.3);">A脱出口</div>
                            <div class="legend-item" style="background: rgba(33, 150, 243, 0.3);">B脱出口</div>
                        </div>
                        
                        <div class="module-selector">
                            <div class="selector-title">配置テンプレート：</div>
                            <div class="option-grid">
                                <div class="option-button selected" onclick="selectModule('placement', 'standard', event)">
                                    標準配置
                                </div>
                                <div class="option-button" onclick="selectModule('placement', 'custom', event)">
                                    カスタム
                                </div>
                            </div>
                        </div>

                        <!-- 説明欄 -->
                        <div class="module-description">
                            <h5>📝 配置戦略の説明</h5>
                            <textarea id="placementDescription" placeholder="この配置戦略について説明してください...&#10;例：&#10;- 前線に悪玉を配置して相手を誘導&#10;- 善玉を後方で守備を固める&#10;- 脱出を狙いやすい位置に善玉を配置">修正エンジン対応配置：ガイスタールール準拠
- プレイヤーAは下側（y=4,5）に配置（修正された座標系）
- プレイヤーBは上側（y=0,1）に配置
- 脱出口：A=相手陣地の上側角(0,0),(5,0)、B=下側角(0,5),(5,5)
- 相手の駒配置は完全に未知として学習</textarea>
                            <div class="description-hint">AIがこの配置を選択する理由や戦略を記載してください</div>
                        </div>
                        
                        <button class="run-button" onclick="runPlacement()">▶ 配置を実行</button>
                        <div class="output-area" id="placementOutput"></div>
                    </div>
                </div>

                <!-- モジュール2: 敵駒推定 -->
                <div class="module-card">
                    <div class="module-title">
                        <span class="module-icon">🔬</span>
                        モジュール2: 敵駒推定（CQCNN）
                    </div>
                    
                    <div class="notebook-cell">
                        <div class="cell-number">In [2]:</div>
                        <div class="quantum-config">
                            <div class="config-item">
                                <label class="config-label">🔢 量子ビット数（n_qubits）:</label>
                                <div class="slider-container">
                                    <input type="range" class="slider" id="qubitsSlider" min="4" max="12" value="4" 
                                           oninput="updateSliderValue('qubits', this.value)">
                                    <div class="value-display" id="qubitsValue">4</div>
                                </div>
                            </div>
                            
                            <div class="config-item">
                                <label class="config-label">📚 レイヤー数（n_layers）:</label>
                                <div class="slider-container">
                                    <input type="range" class="slider" id="layersSlider" min="1" max="5" value="1" 
                                           oninput="updateSliderValue('layers', this.value)">
                                    <div class="value-display" id="layersValue">1</div>
                                </div>
                            </div>
                            
                            <div class="module-selector">
                                <div class="selector-title">エンベディング方式：</div>
                                <div class="option-grid">
                                    <div class="option-button selected" onclick="selectModule('embedding', 'angle', event)">
                                        📐 Angle
                                    </div>
                                    <div class="option-button" onclick="selectModule('embedding', 'amplitude', event)">
                                        📊 Amplitude
                                    </div>
                                </div>
                            </div>
                            
                            <div class="module-selector" style="margin-top: 15px;">
                                <div class="selector-title">エンタングルメント構造：</div>
                                <div class="option-grid">
                                    <div class="option-button selected" onclick="selectModule('entanglement', 'linear', event)">
                                        Linear
                                    </div>
                                    <div class="option-button" onclick="selectModule('entanglement', 'full', event)">
                                        Full
                                    </div>
                                </div>
                            </div>
                            
                            <div class="module-selector" style="margin-top: 15px;">
                                <div class="selector-title">🧠 状態チャンネル数：</div>
                                <div class="option-grid">
                                    <div class="option-button selected" onclick="selectModule('stateChannels', '7', event)">
                                        7CH (252次元)
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- 説明欄 -->
                        <div class="module-description">
                            <h5>🔬 量子推定システムの説明</h5>
                        </div>
                        
                        <button class="run-button" onclick="runQuantumConfig()">▶ 量子回路を構築</button>
                        <div class="output-area" id="quantumOutput"></div>
                    </div>
                </div>

                <!-- モジュール3: 報酬関数 -->
                <div class="module-card">
                    <div class="module-title">
                        <span class="module-icon">💰</span>
                        モジュール3: 報酬関数
                    </div>
                    
                    <div class="notebook-cell">
                        <div class="cell-number">In [3]:</div>
                        <div class="module-selector">
                            <div class="selector-title">報酬戦略：</div>
                            <div class="option-grid">
                                <div class="option-button selected" onclick="selectModule('reward', 'balanced', event)">
                                    ⚖️ バランス型
                                </div>
                            </div>
                        </div>

                        <!-- 説明欄 -->
                        <div class="module-description">
                            <h5>💰 報酬戦略の説明</h5>
                            <div class="description-content">
                                <strong>修正エンジン対応報酬設計（ガイスタールール準拠）</strong><br>
                                • 相手の善玉を捕獲: +10ポイント（有利になる）<br>
                                • 相手の悪玉を捕獲: -5ポイント（相手に有利を与える）<br>
                                • 脱出成功: +100ポイント（勝利条件）<br>
                                • 善玉が取られる: -20ポイント（不利になる）<br>
                                • 悪玉を取らせる: +10ポイント（戦略的価値）<br>
                                • 相手陣地への前進: +3ポイント（脱出への道筋）<br>
                                • 中央制御: +1ポイント（盤面支配）<br>
                                • AIがどのような行動を学習するかを決める重要な要素です
                            </div>
                        </div>
                        
                        <button class="run-button" onclick="runReward()">▶ 報酬関数を設定</button>
                        <div class="output-area" id="rewardOutput"></div>
                    </div>
                </div>

                <!-- モジュール4: Q値マップ -->
                <div class="module-card">
                    <div class="module-title">
                        <span class="module-icon">🗺️</span>
                        モジュール4: Q値
                    </div>
                    
                    <div class="notebook-cell">
                        <div class="cell-number">In [4]:</div>
                        <div class="module-selector">
                            <div class="selector-title">Q値計算方法：</div>
                            <div class="option-grid">
                                <div class="option-button selected" onclick="selectModule('qmap', 'dqn', event)">
                                    🧠 DQN
                                </div>
                                <div class="option-button" onclick="selectModule('qmap', 'full_output', event)">
                                    🗺️ 全状態マップ出力
                                </div>
                                <div class="option-button" onclick="selectModule('qmap', 'heatmap_analysis', event)">
                                    🔥 ヒートマップ分析
                                </div>
                                <div class="option-button" onclick="selectModule('qmap', 'strategic_pattern', event)">
                                    🎯 戦略パターン分析
                                </div>
                                <div class="option-button" onclick="selectModule('qmap', 'comparative_analysis', event)">
                                    📊 比較分析モード
                                </div>
                                <div class="option-button" onclick="selectModule('qmap', 'spatial_36d', event)">
                                    🌐 36次元空間マップ
                                </div>
                                <div class="option-button" onclick="selectModule('qmap', 'enhanced_cnn', event)">
                                    🚀 強化CNN可視化
                                </div>
                            </div>
                        </div>

                        <!-- 説明欄 -->
                        <div class="module-description">
                            <h5>🗺️ Q値学習方式の説明</h5>
                            <div class="description-content" id="qmapDescription">
                                <div id="qmap-dqn" class="description-variant active">
                                    <strong>🧠 DQN (Deep Q-Network)</strong><br>
                                    • 標準的な深層強化学習手法<br>
                                    • 経験リプレイとターゲットネットワークを使用<br>
                                    • 安定した学習で基本的なQ値を計算<br>
                                    • 一般的な用途に適用可能
                                </div>
                                <div id="qmap-full_output" class="description-variant">
                                    <strong>🗺️ 全状態マップ出力</strong><br>
                                    • <strong>すべての可能な盤面状態のQ値を完全計算</strong><br>
                                    • 1,000〜10,000状態の大規模分析<br>
                                    • JSON/CSV/可視化形式で詳細出力<br>
                                    • 戦略パターンの包括的理解が可能<br>
                                    • <em>計算時間: 5-15分（状態数による）</em>
                                </div>
                                <div id="qmap-heatmap_analysis" class="description-variant">
                                    <strong>🔥 ヒートマップ分析</strong><br>
                                    • Q値を色分けした視覚的マップ<br>
                                    • 行動別の価値分布を一目で把握<br>
                                    • 高Q値エリアと低Q値エリアを識別<br>
                                    • 戦略的要地の特定に有効
                                </div>
                                <div id="qmap-strategic_pattern" class="description-variant">
                                    <strong>🎯 戦略パターン分析</strong><br>
                                    • 攻撃型・守備型・脱出型・バランス型に分類<br>
                                    • 各パターンの出現頻度と特徴を分析<br>
                                    • AIの戦略傾向を定量的に評価<br>
                                    • 学習の偏りや改善点を発見
                                </div>
                                <div id="qmap-comparative_analysis" class="description-variant">
                                    <strong>📊 比較分析モード</strong><br>
                                    • 異なるパラメータ設定での結果比較<br>
                                    • 量子ビット数・レイヤー数の影響評価<br>
                                    • 学習前後のQ値変化を追跡<br>
                                    • 最適な設定の発見をサポート
                                </div>
                                <div id="qmap-spatial_36d" class="description-variant">
                                    <strong>🌐 36次元空間マップ</strong><br>
                                    • <strong>6x6空間グリッドでQ値を36次元出力</strong><br>
                                    • 従来の5行動から空間的な価値マップへ進化<br>
                                    • 盤面の各位置における価値を直接可視化<br>
                                    • 局所的な戦略パターンと空間分布を解析<br>
                                    • <em>5行動Q値との比較分析も同時実行</em>
                                </div>
                                <div id="qmap-enhanced_cnn" class="description-variant">
                                    <strong>🚀 強化CNN可視化システム</strong><br>
                                    • <strong>647K+パラメータの超深層アーキテクチャ</strong><br>
                                    • 前処理CNN: 252→512→256→128→64→4次元<br>
                                    • 量子回路: 4量子ビット・2層・特徴増強付き<br>
                                    • 後処理CNN: 4→128→256→512→256→128→64→36次元<br>
                                    • <em>LayerNorm+Dropout・201.5 FPS高速推論</em><br>
                                    • リアルタイム中間層可視化・勾配フロー分析
                                </div>
                            </div>
                        </div>
                        
                        <button class="run-button" onclick="runQMap()">▶ Q値を生成</button>
                        <div class="output-area" id="qmapOutput"></div>
                    </div>
                </div>

                <!-- モジュール5: 行動選択 -->
                <div class="module-card">
                    <div class="module-title">
                        <span class="module-icon">🎯</span>
                        モジュール5: 行動選択
                    </div>
                    
                    <div class="notebook-cell">
                        <div class="cell-number">In [5]:</div>
                        <div class="module-selector">
                            <div class="selector-title">行動選択戦略：</div>
                            <div class="option-grid">
                                <div class="option-button selected" onclick="selectModule('action', 'epsilon', event)">
                                    🎰 ε-greedy
                                </div>
                            </div>
                        </div>

                        
                        <button class="run-button" onclick="runAction()">▶ 行動選択戦略を設定</button>
                        <div class="output-area" id="actionOutput"></div>
                    </div>
                </div>
            </div>

            <div class="button-container">
                <button class="btn btn-secondary" onclick="showStep(1)">← 戻る</button>
                <button class="btn btn-primary" onclick="proceedToStep3()">次へ進む →</button>
            </div>
        </div>

        <!-- ステップ3: ハイパーパラメータ設定 -->
        <div class="step-content" id="step3">
            <div class="hyperparameter-container">
                <!-- 学習設定 -->
                <div class="param-section">
                    <div class="param-section-title">
                        <span>⚙️</span>
                        学習設定
                    </div>
                    <div class="param-grid">
                        <div class="param-item">
                            <label class="param-label">
                                <span>📊</span> 学習率 (Learning Rate)
                                <small style="color: #666; font-weight: normal;">- AIの学習速度を制御</small>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" min="-4" max="-1" value="-3" step="0.1"
                                       oninput="updateLearningRate(this.value)">
                                <div class="value-display" id="lrValue">0.001</div>
                            </div>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>📦</span> バッチサイズ
                                <small style="color: #666; font-weight: normal;">- 一度に処理する経験数</small>
                            </label>
                            <select class="param-input" id="batchSize">
                                <option value="4">4</option>
                                <option value="8" selected>8</option>
                                <option value="16">16</option>
                                <option value="32">32</option>
                                <option value="256">256</option>
                            </select>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>🔄</span> エポック数
                                <small style="color: #666; font-weight: normal;">- 学習の繰り返し回数</small>
                            </label>
                            <input type="number" class="param-input" id="epochs" value="5" min="1" max="1000">
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>🎯</span> 検証データ割合
                                <small style="color: #666; font-weight: normal;">- 学習効果の検証用データ比率</small>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" min="0.1" max="0.4" value="0.2" step="0.05"
                                       oninput="updateSliderValue('validation', this.value)">
                                <div class="value-display" id="validationValue">0.2</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 強化学習固有のパラメータ -->
                <div class="param-section" id="rlParams">
                    <div class="param-section-title">
                        <span>🎮</span>
                        強化学習パラメータ
                    </div>
                    <div class="param-grid">
                        <div class="param-item">
                            <label class="param-label">
                                <span>🎰</span> ε (Epsilon)
                                <small style="color: #666; font-weight: normal;">- ランダム探索の確率</small>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" min="0" max="1" value="0.1" step="0.01"
                                       oninput="updateSliderValue('epsilon', this.value)">
                                <div class="value-display" id="epsilonValue">0.1</div>
                            </div>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>📉</span> ε減衰率
                                <small style="color: #666; font-weight: normal;">- 探索率を徐々に減らす速度</small>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" min="0.99" max="1" value="0.995" step="0.001"
                                       oninput="updateSliderValue('epsilonDecay', this.value)">
                                <div class="value-display" id="epsilonDecayValue">0.995</div>
                            </div>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>💾</span> リプレイバッファサイズ
                                <small style="color: #666; font-weight: normal;">- 過去の経験を記憶する容量</small>
                            </label>
                            <select class="param-input" id="replayBuffer">
                                <option value="500">500</option>
                                <option value="1000" selected>1,000</option>
                                <option value="10000">10,000</option>
                                <option value="50000">50,000</option>
                            </select>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>🎯</span> 割引率 (γ)
                                <small style="color: #666; font-weight: normal;">- 未来報酬の重視度</small>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" min="0.9" max="1" value="0.99" step="0.01"
                                       oninput="updateSliderValue('gamma', this.value)">
                                <div class="value-display" id="gammaValue">0.99</div>
                            </div>
                        </div>
                    </div>
                </div>


                <!-- 最適化設定 -->
                <div class="param-section">
                    <div class="param-section-title">
                        <span>🚀</span>
                        最適化設定
                    </div>
                    <div class="param-grid">
                        <div class="param-item">
                            <label class="param-label">
                                <span>⚡</span> オプティマイザ
                                <small style="color: #666; font-weight: normal;">- 重み更新の方法</small>
                            </label>
                            <select class="param-input" id="optimizer">
                                <option value="adam" selected>Adam</option>
                                <option value="sgd">SGD</option>
                                <option value="rmsprop">RMSprop</option>
                                <option value="adamw">AdamW</option>
                            </select>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>📈</span> 学習率スケジューラ
                                <small style="color: #666; font-weight: normal;">- 学習率の動的調整</small>
                            </label>
                            <select class="param-input" id="scheduler">
                                <option value="none">なし</option>
                                <option value="step">Step</option>
                                <option value="cosine" selected>Cosine</option>
                                <option value="exponential">Exponential</option>
                            </select>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>💧</span> Dropout率
                                <small style="color: #666; font-weight: normal;">- 過学習防止のための無効化率</small>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" min="0" max="0.5" value="0.2" step="0.05"
                                       oninput="updateSliderValue('dropout', this.value)">
                                <div class="value-display" id="dropoutValue">0.2</div>
                            </div>
                        </div>
                        <div class="param-item">
                            <label class="param-label">
                                <span>🔒</span> L2正則化
                                <small style="color: #666; font-weight: normal;">- 重みの大きさにペナルティ</small>
                            </label>
                            <div class="slider-container">
                                <input type="range" class="slider" min="-5" max="-2" value="-4" step="0.5"
                                       oninput="updateL2Reg(this.value)">
                                <div class="value-display" id="l2Value">0.0001</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="button-container">
                    <button class="btn btn-secondary" onclick="showStep(2)">← 戻る</button>
                    <button class="btn btn-success" onclick="generateCode()">コード生成 🚀</button>
                </div>
            </div>

            <!-- コード出力エリア -->
            <div class="code-output" id="codeOutput" style="display: none;">
                <div class="code-header">
                    <div class="code-title">📝 Generated Python Code</div>
                    <button class="copy-button" onclick="copyCode()">📋 コピー</button>
                </div>
                <pre id="generatedCode"></pre>
            </div>
        </div>

    </div>

    <style>
    </style>

    <script>
        // 設定管理
        const config = {
            learningMethod: '',
            placement: 'standard',
            qubits: 4,
            layers: 1,
            embedding: 'angle',
            entanglement: 'linear',
            reward: 'balanced',
            qmap: 'dqn',
            action: 'epsilon',
            board: Array(6).fill().map(() => Array(6).fill(0)),
            playerAPieces: { good: [], bad: [] },
            playerBPieces: { good: [], bad: [] }
        };

        const hyperparams = {
            learningRate: 0.001,
            batchSize: 8,
            epochs: 5,
            validation: 0.2,
            epsilon: 0.1,
            epsilonDecay: 0.995,
            replayBuffer: 1000,
            gamma: 0.99,
            dropout: 0.2,
            l2Reg: 0.0001,
            optimizer: 'adam',
            scheduler: 'cosine'
        };

        // 初期化
        window.onload = () => {
            initializeBoard();
        };

        // 正しいガイスターボード初期化
        function initializeBoard() {
            const board = document.getElementById('placementBoard');
            if (!board) return;
            
            board.innerHTML = '';
            
            // 6x6ボードを作成
            for (let i = 0; i < 6; i++) {
                for (let j = 0; j < 6; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'board-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    // プレイヤーA配置エリア（下側2行、中央4列）
                    if ((i === 0 || i === 1) && (j >= 1 && j <= 4)) {
                        cell.classList.add('player-a-area');
                        cell.title = 'プレイヤーA配置エリア';
                    }
                    // プレイヤーB配置エリア（上側2行、中央4列）
                    else if ((i === 4 || i === 5) && (j >= 1 && j <= 4)) {
                        cell.classList.add('player-b-area');
                        cell.title = 'プレイヤーB配置エリア';
                    }
                    
                    // 脱出口の表示（正しいガイスタールール）
                    if ((i === 0 && j === 0) || (i === 0 && j === 5)) {
                        cell.classList.add('escape-a');
                        cell.title = 'プレイヤーA脱出口（相手陣地の角）';
                        cell.textContent = '🚪';
                    }
                    if ((i === 5 && j === 0) || (i === 5 && j === 5)) {
                        cell.classList.add('escape-b');
                        cell.title = 'プレイヤーB脱出口（相手陣地の角）';
                        cell.textContent = '🚪';
                    }
                    
                    // プレイヤーAエリア（下側2行）のみクリック可能
                    if ((i === 0 || i === 1) && (j >= 1 && j <= 4)) {
                        cell.onclick = () => togglePiece(i, j);
                    } else if ((i === 4 || i === 5) && (j >= 1 && j <= 4)) {
                        // 相手エリアには警告メッセージのみ
                        cell.onclick = () => {
                            alert('相手の駒エリアは編集できません（ガイスタールール準拠）');
                        };
                    }
                    board.appendChild(cell);
                }
            }
            
            // 初期配置を設定
            setStandardPlacement();
        }

        // モジュール実行関数（Jupyter Notebook スタイル）
        function runPlacement() {
            const output = document.getElementById('placementOutput');
            output.style.display = 'block';
            let goodCount = 0, badCount = 0;
            for (let row of config.board) {
                for (let val of row) {
                    if (val > 0) goodCount++;
                    if (val < 0) badCount++;
                }
            }
            output.textContent = `✅ 初期配置設定完了
配置タイプ: ${config.placement}
善玉の位置: ${goodCount}個
悪玉の位置: ${badCount}個`;
        }

        function runQuantumConfig() {
            const output = document.getElementById('quantumOutput');
            output.style.display = 'block';
            output.textContent = `✅ 量子回路構築完了
量子ビット数: ${config.qubits}
レイヤー数: ${config.layers}
エンベディング: ${config.embedding}
エンタングルメント: ${config.entanglement}
総パラメータ数: ${config.qubits * config.layers * 3}`;
        }

        function runReward() {
            const output = document.getElementById('rewardOutput');
            output.style.display = 'block';
            const rewards = {
                balanced: '捕獲: +10, 脱出: +50, 被捕獲: -10',
                aggressive: '捕獲: +20, 脱出: +30, 被捕獲: -5',
                defensive: '捕獲: +5, 脱出: +40, 被捕獲: -20',
                escape: '捕獲: +5, 脱出: +100, 被捕獲: -10'
            };
            output.textContent = `✅ 報酬関数設定完了
戦略: ${config.reward}
${rewards[config.reward]}`;
        }

        function runQMap() {
            const output = document.getElementById('qmapOutput');
            output.style.display = 'block';
            
            // Q値マップタイプ別の処理
            const qmapDescriptions = {
                'dqn': {
                    title: '✅ DQN Q値マップ生成完了',
                    content: `方法: Deep Q-Network
状態空間: 252次元（7チャンネル）
行動空間: 5方向（上下左右+脱出）
推定計算時間: 30秒`
                },
                'full_output': {
                    title: '🗺️ 全状態マップ出力開始',
                    content: `🚀 完全Q値マップ分析を実行中...

分析内容:
• 1,000〜10,000状態の完全計算
• 戦略パターン分析（攻撃型・守備型・脱出型・バランス型）
• ヒートマップ生成
• JSON/CSV/可視化出力

💡 コマンドライン実行:
python qvalue_full_output_module.py 2

推定時間: 5-15分
結果保存: qvalue_analysis_results/`
                },
                'heatmap_analysis': {
                    title: '🔥 Q値ヒートマップ分析',
                    content: `視覚化内容:
• 5つの行動別Q値分布
• 高価値エリア（赤色）の特定
• 低価値エリア（青色）の特定
• 戦略的要地マップ

出力形式: PNG, SVG, インタラクティブHTML`
                },
                'strategic_pattern': {
                    title: '🎯 戦略パターン分析',
                    content: `分析パターン:
• 攻撃型: 前進重視戦略
• 守備型: 後退・保守戦略  
• 脱出型: 脱出最優先戦略
• バランス型: 状況適応戦略

統計出力:
• 各パターンの出現頻度
• Q値分散の比較
• 最適戦略の推奨`
                },
                'comparative_analysis': {
                    title: '📊 比較分析モード',
                    content: `比較項目:
• 量子ビット数の影響（2, 4, 6, 8ビット）
• レイヤー数の影響（1, 2, 3レイヤー）
• 学習率の影響
• 学習前後の変化追跡

グラフ出力:
• パフォーマンス比較チャート
• パラメータ感度分析
• 収束速度比較`
                },
                'spatial_36d': {
                    title: '🌐 36次元空間Q値マップ生成',
                    content: `🚀 新世代36次元Q値マップ分析

出力形式:
• 36次元ベクトル → 6x6空間マップ変換
• 従来5行動Q値との同時出力・比較
• 空間的ホットスポット検出と可視化

分析内容:
• 6x6グリッド各位置の価値分布
• 空間分散と局所パターン解析
• 5行動システムとの戦略比較
• 位置別最適行動マッピング

💡 実行コマンド:
python qvalue_full_output_module.py 2

推定時間: 5-10分
結果: 空間マップPNG + 比較分析チャート`
                },
                'enhanced_cnn': {
                    title: '🚀 強化CNN可視化システム起動',
                    content: `⚡ 超深層647K+パラメータネットワーク分析

アーキテクチャ:
• 前処理CNN: 252→512→256→128→64→4
• 量子特徴増強: 4→8→4 (2層エンハンサー)
• 量子回路: 4量子ビット・2層処理・caching対応
• 後処理CNN: 4→128→256→512→256→128→64→36

パフォーマンス:
• 推論速度: 201.5 FPS
• メモリ使用量: 2.47 MB
• 1000エピソード推定: 0.1分

可視化内容:
• 中間層アクティベーション分析
• 勾配フロー・重み分布可視化
• 量子特徴マップ・空間Q値ヒートマップ
• リアルタイム推論パフォーマンス監視

💡 実行コマンド:
python test_enhanced_cnn.py

推定時間: 1-2分
結果: 完全アーキテクチャ分析レポート`
                }
            };
            
            const description = qmapDescriptions[config.qmap] || qmapDescriptions['dqn'];
            
            output.innerHTML = `<div class="qmap-output">
                <h4>${description.title}</h4>
                <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 10px 0; white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 12px;">${description.content}</pre>
                ${(config.qmap === 'full_output' || config.qmap === 'spatial_36d' || config.qmap === 'enhanced_cnn') ? 
                    `<div style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="executeQMapAnalysis()" style="margin-right: 10px;">
                            🚀 分析実行
                        </button>
                        <button class="btn btn-secondary" onclick="viewPreviousResults()">
                            📁 過去の結果を表示
                        </button>
                        ${config.qmap === 'spatial_36d' ? 
                            `<button class="btn btn-info" onclick="showSpatialMapInfo()" style="margin-left: 10px;">
                                🌐 36次元マップ詳細
                            </button>` : ''
                        }
                        ${config.qmap === 'enhanced_cnn' ? 
                            `<button class="btn btn-warning" onclick="showEnhancedCNNDetails()" style="margin-left: 10px;">
                                🚀 CNN詳細分析
                            </button>
                            <button class="btn btn-success" onclick="runRealTimeVisualization()" style="margin-left: 10px;">
                                📊 リアルタイム可視化
                            </button>` : ''
                        }
                    </div>` : ''
                }
            </div>`;
        }
        
        function executeQMapAnalysis() {
            const output = document.getElementById('qmapOutput');
            const analyzeType = config.qmap === 'spatial_36d' ? '36次元空間Q値マップ' : 'Q値マップ';
            
            output.innerHTML += `
                <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 5px; border-left: 4px solid #2196f3;">
                    <strong>📊 ${analyzeType}実行ステータス:</strong><br>
                    1. 学習済みモデル確認中...<br>
                    2. 盤面状態生成中...<br>
                    3. ${config.qmap === 'spatial_36d' ? '36次元Q値計算実行中...<br>4. 6x6空間マップ変換中...<br>5. 5行動Q値比較実行中...' : 'Q値計算実行中...<br>4. 戦略パターン分析中...'}<br>
                    ${config.qmap === 'spatial_36d' ? '6. 空間ホットスポット解析中...<br>7. 可視化生成中...' : '5.'} 結果出力中...<br><br>
                    
                    <em>💡 実際の実行は、fast_quantum_trainer.pyで学習完了後に行ってください。</em><br>
                    <code>python qvalue_full_output_module.py</code>
                    ${config.qmap === 'spatial_36d' ? '<br><em>※ 36次元空間マップモードでは追加の可視化ファイルが生成されます</em>' : ''}
                </div>`;
        }
        
        function showSpatialMapInfo() {
            const output = document.getElementById('qmapOutput');
            output.innerHTML += `
                <div style="margin-top: 15px; padding: 15px; background: #f3e5f5; border-radius: 8px; border: 2px solid #9c27b0;">
                    <h5 style="color: #7b1fa2; margin-bottom: 10px;">🌐 36次元空間Q値マップ詳細解説</h5>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <h6 style="color: #4a148c;">📐 技術仕様:</h6>
                            <ul style="font-size: 12px; margin: 5px 0;">
                                <li>出力次元: 36 (6×6グリッド)</li>
                                <li>入力: 252次元 (7チャンネル)</li>
                                <li>量子ビット: 4量子ビット</li>
                                <li>後処理: 4→32→36次元</li>
                            </ul>
                        </div>
                        <div>
                            <h6 style="color: #4a148c;">📊 出力ファイル:</h6>
                            <ul style="font-size: 12px; margin: 5px 0;">
                                <li>*_spatial.png: 9個サンプル空間マップ</li>
                                <li>*_comparison.png: 5行動vs36次元比較</li>
                                <li>JSON: ホットスポット座標データ</li>
                                <li>CSV: 空間分散統計</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div style="background: #fce4ec; padding: 10px; border-radius: 5px; font-size: 12px;">
                        <strong>🔬 分析ポイント:</strong><br>
                        • 6×6グリッドの各セルが盤面位置の価値を表現<br>
                        • 従来の上下左右脱出(5行動)を空間的に拡張<br>
                        • 局所的な価値パターンと大域的戦略の両方を可視化<br>
                        • AIが「どの位置を重要視するか」を直接観察可能
                    </div>
                </div>`;
        }
        
        function showEnhancedCNNDetails() {
            const output = document.getElementById('qmapOutput');
            output.innerHTML += `
                <div style="margin-top: 15px; padding: 20px; background: #e8f5e8; border-radius: 12px; border: 3px solid #4caf50;">
                    <h5 style="color: #2e7d32; margin-bottom: 15px;">🚀 強化CNN詳細アーキテクチャ分析</h5>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <h6 style="color: #1b5e20;">🧠 前処理CNN:</h6>
                            <ul style="font-size: 11px; margin: 5px 0;">
                                <li>Layer 1: 252→512 (LayerNorm+ReLU+Dropout 0.2)</li>
                                <li>Layer 2: 512→256 (LayerNorm+ReLU+Dropout 0.15)</li>
                                <li>Layer 3: 256→128 (LayerNorm+ReLU+Dropout 0.1)</li>
                                <li>Layer 4: 128→64 (LayerNorm+ReLU+Dropout 0.05)</li>
                                <li>Layer 5: 64→4 (Tanh 量子正規化)</li>
                            </ul>
                        </div>
                        <div>
                            <h6 style="color: #1b5e20;">⚛️ 量子処理:</h6>
                            <ul style="font-size: 11px; margin: 5px 0;">
                                <li>量子特徴増強: 4→8→4</li>
                                <li>量子回路: 4量子ビット・2層</li>
                                <li>デバイス: Lightning.qubit (fallback: default)</li>
                                <li>キャッシュ: LRU 10,000サンプル</li>
                                <li>事前計算パターン: 3種類</li>
                            </ul>
                        </div>
                        <div>
                            <h6 style="color: #1b5e20;">🎯 後処理CNN:</h6>
                            <ul style="font-size: 11px; margin: 5px 0;">
                                <li>Layer 1: 4→128 (LayerNorm+ReLU+Dropout 0.1)</li>
                                <li>Layer 2: 128→256→512 (拡張)</li>
                                <li>Layer 3-5: 512→256→128→64 (収束)</li>
                                <li>Output: 64→36 (Tanh正規化)</li>
                                <li>空間形状: 6×6 Q値マップ</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div style="background: #c8e6c9; padding: 10px; border-radius: 8px;">
                            <strong style="color: #2e7d32;">⚡ パフォーマンス指標:</strong><br>
                            <span style="font-size: 12px;">
                                • 総パラメータ: 647,044個<br>
                                • メモリ使用量: 2.47 MB<br>
                                • 推論速度: 201.5 FPS<br>
                                • バッチ推論: 0.0056秒/サンプル<br>
                                • 1000エピソード: 0.1分（推定）
                            </span>
                        </div>
                        <div style="background: #dcedc8; padding: 10px; border-radius: 8px;">
                            <strong style="color: #33691e;">🔬 可視化機能:</strong><br>
                            <span style="font-size: 12px;">
                                • 中間層アクティベーション分析<br>
                                • 勾配フロー可視化<br>
                                • 重み分布ヒストグラム<br>
                                • 量子特徴マップ表示<br>
                                • リアルタイム推論監視
                            </span>
                        </div>
                    </div>
                </div>`;
        }
        
        function runRealTimeVisualization() {
            const output = document.getElementById('qmapOutput');
            output.innerHTML += `
                <div style="margin-top: 15px; padding: 15px; background: #e3f2fd; border-radius: 10px; border: 2px solid #2196f3;">
                    <h5 style="color: #1976d2; margin-bottom: 10px;">📊 リアルタイム可視化システム起動中...</h5>
                    
                    <div style="margin-bottom: 15px;">
                        <div style="background: #bbdefb; padding: 8px; border-radius: 5px; margin: 5px 0;">
                            <strong>🔄 1/6: モデル初期化中...</strong> <span style="color: #4caf50;">✅ 完了</span><br>
                            <small>• 647K+パラメータ読み込み完了</small>
                        </div>
                        <div style="background: #bbdefb; padding: 8px; border-radius: 5px; margin: 5px 0;">
                            <strong>🔄 2/6: 可視化エンジン起動中...</strong> <span style="color: #ff9800;">⏳ 処理中</span><br>
                            <small>• 中間層フック設定・勾配監視準備</small>
                        </div>
                        <div style="background: #e1f5fe; padding: 8px; border-radius: 5px; margin: 5px 0;">
                            <strong>🔄 3/6: データパイプライン構築中...</strong> <span style="color: #9e9e9e;">⏸️ 待機中</span><br>
                            <small>• リアルタイムデータフロー準備</small>
                        </div>
                        <div style="background: #e1f5fe; padding: 8px; border-radius: 5px; margin: 5px 0;">
                            <strong>🔄 4/6: Web可視化サーバー起動...</strong> <span style="color: #9e9e9e;">⏸️ 待機中</span><br>
                            <small>• WebSocket接続・リアルタイム更新準備</small>
                        </div>
                        <div style="background: #e1f5fe; padding: 8px; border-radius: 5px; margin: 5px 0;">
                            <strong>🔄 5/6: 量子状態監視開始...</strong> <span style="color: #9e9e9e;">⏸️ 待機中</span><br>
                            <small>• 量子回路状態・キャッシュヒット率監視</small>
                        </div>
                        <div style="background: #e1f5fe; padding: 8px; border-radius: 5px; margin: 5px 0;">
                            <strong>🔄 6/6: ダッシュボード表示...</strong> <span style="color: #9e9e9e;">⏸️ 待機中</span><br>
                            <small>• リアルタイム可視化画面表示</small>
                        </div>
                    </div>
                    
                    <div style="background: #f3e5f5; padding: 12px; border-radius: 8px; border-left: 4px solid #9c27b0;">
                        <strong>💡 リアルタイム可視化機能:</strong><br>
                        <span style="font-size: 12px;">
                            • <strong>推論監視:</strong> FPS・レイテンシ・スループット<br>
                            • <strong>アクティベーション:</strong> 各層の出力分布・統計<br>
                            • <strong>勾配分析:</strong> 逆伝播フロー・勾配ノルム<br>
                            • <strong>量子状態:</strong> 量子ビット状態・エンタングルメント<br>
                            • <strong>Q値マップ:</strong> 6×6空間価値分布・ホットスポット<br>
                            • <strong>メモリ使用:</strong> GPU/CPU使用率・キャッシュ状態
                        </span>
                    </div>
                </div>`;
                
            // Simulate loading progress
            setTimeout(() => {
                const elements = output.querySelectorAll('[style*="⏳ 処理中"]');
                if (elements.length > 0) {
                    elements[0].innerHTML = '<span style="color: #4caf50;">✅ 完了</span>';
                    elements[0].parentElement.style.background = '#c8e6c9';
                    
                    const nextElement = elements[0].parentElement.nextElementSibling;
                    if (nextElement) {
                        nextElement.querySelector('span').innerHTML = '<span style="color: #ff9800;">⏳ 処理中</span>';
                        nextElement.style.background = '#bbdefb';
                    }
                }
            }, 2000);
        }
        
        function viewPreviousResults() {
            const output = document.getElementById('qmapOutput');
            output.innerHTML += `
                <div style="margin-top: 15px; padding: 10px; background: #f3e5f5; border-radius: 5px; border-left: 4px solid #9c27b0;">
                    <strong>📂 過去の分析結果:</strong><br>
                    • qvalue_analysis_results/qvalue_full_output.json<br>
                    • qvalue_analysis_results/qvalue_heatmap.png<br>
                    • qvalue_analysis_results/qvalue_summary.csv<br>
                    • qvalue_analysis_results/qvalue_complete_data.pkl<br><br>
                    
                    <em>結果ファイルが存在する場合、ブラウザで確認できます。</em>
                </div>`;
        }

        function runAction() {
            const output = document.getElementById('actionOutput');
            output.style.display = 'block';
            const strategies = {
                epsilon: 'ε=0.1で10%の確率でランダム探索',
                boltzmann: '温度τ=1.0でソフトマックス選択',
                ucb: '信頼区間による楽観的探索',
                thompson: 'ベイズ的確率分布からサンプリング'
            };
            output.textContent = `✅ 行動選択戦略設定完了
戦略: ${config.action}
${strategies[config.action]}`;
        }

        // 標準配置の設定
        function setStandardPlacement() {
            // ボードをリセット
            config.board = Array(6).fill().map(() => Array(6).fill(0));
            config.playerAPieces = { good: [], bad: [] };
            config.playerBPieces = { good: [], bad: [] };
            
            // プレイヤーA: 下側2行（0-1行）中央4列（1-4列）にランダム配置
            const playerAPositions = [
                [0, 1], [0, 2], [0, 3], [0, 4],
                [1, 1], [1, 2], [1, 3], [1, 4]
            ];
            
            // プレイヤーB: 上側2行（4-5行）中央4列（1-4列） - グレー駒として表示
            const playerBPositions = [
                [4, 1], [4, 2], [4, 3], [4, 4],
                [5, 1], [5, 2], [5, 3], [5, 4]
            ];
            
            // 駒の種類をランダムに配置（善玉4個、悪玉4個）
            const pieceTypes = ['good', 'good', 'good', 'good', 'bad', 'bad', 'bad', 'bad'];
            
            // プレイヤーAの配置（編集可能）
            const shuffledTypesA = [...pieceTypes].sort(() => Math.random() - 0.5);
            playerAPositions.forEach(([row, col], index) => {
                const type = shuffledTypesA[index];
                config.board[row][col] = type === 'good' ? 1 : -1; // A善玉=1, A悪玉=-1
                config.playerAPieces[type].push([row, col]);
            });
            
            // プレイヤーBの配置（内部でのみ管理、表示は全てグレー駒）
            const shuffledTypesB = [...pieceTypes].sort(() => Math.random() - 0.5);
            playerBPositions.forEach(([row, col], index) => {
                const type = shuffledTypesB[index];
                // ボードには未知駒として統一値を設定（種類を隠蔽）
                config.board[row][col] = 9; // 9 = 相手の駒（種類不明）
                config.playerBPieces[type].push([row, col]);
            });
            
            updateBoardDisplay();
        }

        // ボード表示の更新
        function updateBoardDisplay() {
            const board = document.getElementById('placementBoard');
            const cells = board.querySelectorAll('.board-cell');
            
            cells.forEach((cell, index) => {
                const row = Math.floor(index / 6);
                const col = index % 6;
                const value = config.board[row][col];
                
                // 既存のクラスを保持しつつ、駒の状態を更新
                cell.className = 'board-cell';
                
                // エリア表示を再追加
                if ((row === 0 || row === 1) && (col >= 1 && col <= 4)) {
                    cell.classList.add('player-a-area');
                }
                else if ((row === 4 || row === 5) && (col >= 1 && col <= 4)) {
                    cell.classList.add('player-b-area');
                }
                
                // 脱出口表示を再追加（正しいルール）
                if ((row === 0 && col === 0) || (row === 0 && col === 5)) {
                    cell.classList.add('escape-a');
                    if (value === 0) cell.textContent = '🚪';
                }
                if ((row === 5 && col === 0) || (row === 5 && col === 5)) {
                    cell.classList.add('escape-b');
                    if (value === 0) cell.textContent = '🚪';
                }
                
                // 駒の表示
                if (value === 1) {
                    cell.classList.add('player-a-good');
                    cell.textContent = '○';
                    cell.title = 'プレイヤーA 善玉（編集可能）';
                } else if (value === -1) {
                    cell.classList.add('player-a-bad');
                    cell.textContent = '●';
                    cell.title = 'プレイヤーA 悪玉（編集可能）';
                } else if (value === 9) {
                    // 相手の駒は全て未知のグレー駒として表示
                    cell.classList.add('player-b-unknown');
                    cell.textContent = '?';
                    cell.title = '相手の駒（善玉/悪玉不明・編集不可）';
                }
            });
        }

        // ピース切り替え（カスタムモード時）
        function togglePiece(row, col) {
            if (config.placement !== 'custom') {
                alert('カスタムモードを選択してから駒を編集してください');
                return;
            }
            
            // プレイヤーAエリアの確認（下側2行の中央4列のみ）
            const isPlayerAArea = (row === 0 || row === 1) && (col >= 1 && col <= 4);
            
            if (!isPlayerAArea) {
                alert('この位置には駒を配置できません（ガイスタールール準拠）');
                return;
            }
            
            const current = config.board[row][col];
            
            // プレイヤーAエリアのみ編集可能: 0 → 1(善玉) → -1(悪玉) → 0
            const next = current === 0 ? 1 : current === 1 ? -1 : 0;
            
            config.board[row][col] = next;
            updateBoardDisplay();
        }

        // 学習方法選択
        function selectLearningMethod(method) {
            config.learningMethod = method;
            
            document.querySelectorAll('.method-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            if (method === 'reinforcement') {
                document.getElementById('rl-card').classList.add('selected');
            } else {
                document.getElementById('sl-card').classList.add('selected');
            }
        }

        // ステップ2へ進む
        function proceedToStep2() {
            console.log('proceedToStep2 called');
            // 強制的に強化学習を設定
            config.learningMethod = 'reinforcement';
            console.log('Set learningMethod to:', config.learningMethod);
            // 直接Step2を表示
            showStep(2);
        }

        // ステップ3へ進む
        function proceedToStep3() {
            console.log('proceedToStep3 called');
            showStep(3);
            // 強化学習パラメータを表示
            const rlParams = document.getElementById('rlParams');
            if (rlParams) {
                rlParams.style.display = 'block';
            }
        }

        // シンプルで確実なステップ表示
        function showStep(stepNum) {
            console.log('showStep called with:', stepNum);
            
            // すべてのステップを非表示
            document.querySelectorAll('.step-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // すべてのナビゲーションを非アクティブ
            document.querySelectorAll('.step-item').forEach(item => {
                item.classList.remove('active', 'completed');
            });
            
            // 指定されたステップを表示
            const targetStep = document.getElementById(`step${stepNum}`);
            const navItem = document.getElementById(`nav-step${stepNum}`);
            
            if (targetStep) {
                targetStep.classList.add('active');
                console.log('Added active to:', targetStep.id);
            }
            
            if (navItem) {
                navItem.classList.add('active');
            }
            
            // 完了済みステップにマーク
            for (let i = 1; i < stepNum; i++) {
                const prevNav = document.getElementById(`nav-step${i}`);
                const connector = document.getElementById(`connector${i}`);
                if (prevNav) {
                    prevNav.classList.add('completed');
                }
                if (connector) {
                    connector.classList.add('completed');
                }
            }
        }


        // モジュール選択
        function selectModule(type, value, event) {
            config[type] = value;
            
            // ボタンの選択状態を更新
            const container = event.target.parentElement;
            container.querySelectorAll('.option-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');
            
            // 配置タイプが変更された場合、ボードを更新
            if (type === 'placement') {
                if (value === 'standard') {
                    setStandardPlacement();
                } else if (value === 'aggressive') {
                    setAggressivePlacement();
                } else if (value === 'defensive') {
                    setDefensivePlacement();
                }
                // customの場合は現在の配置を保持
            }
            
            // Q値マップの説明切り替え
            if (type === 'qmap') {
                document.querySelectorAll('.description-variant').forEach(desc => {
                    desc.classList.remove('active');
                });
                const targetDesc = document.getElementById(`qmap-${value}`);
                if (targetDesc) {
                    targetDesc.classList.add('active');
                }
            }
        }
        
        // 攻撃的配置
        function setAggressivePlacement() {
            setStandardPlacement(); // まず標準配置を作成
            // 実際の攻撃的配置ロジックは標準配置をベースとする
        }

        // 防御的配置
        function setDefensivePlacement() {
            setStandardPlacement(); // まず標準配置を作成
            // 実際の防御的配置ロジックは標準配置をベースとする
        }

        // スライダー値更新
        function updateSliderValue(param, value) {
            document.getElementById(`${param}Value`).textContent = value;
            if (param === 'qubits' || param === 'layers') {
                config[param] = parseInt(value);
            } else {
                hyperparams[param] = parseFloat(value);
            }
        }

        // 学習率更新（対数スケール）
        function updateLearningRate(value) {
            const lr = Math.pow(10, parseFloat(value));
            hyperparams.learningRate = lr;
            document.getElementById('lrValue').textContent = lr.toFixed(4);
        }

        // L2正則化更新（対数スケール）
        function updateL2Reg(value) {
            const l2 = Math.pow(10, parseFloat(value));
            hyperparams.l2Reg = l2;
            document.getElementById('l2Value').textContent = l2.toFixed(5);
        }

        // コード生成
        function generateCode() {
            console.log('generateCode called');
            
            // ハイパーパラメータの取得
            const batchSize = document.getElementById('batchSize')?.value || '32';
            const epochs = document.getElementById('epochs')?.value || '100';
            const optimizer = document.getElementById('optimizer')?.value || 'adam';
            const scheduler = document.getElementById('scheduler')?.value || 'cosine';
            const replayBuffer = document.getElementById('replayBuffer')?.value || '10000';
            
            console.log('Parameters collected:', {batchSize, epochs, optimizer, scheduler});
            
            // 説明欄の内容を取得
            const placementDesc = document.getElementById('placementDescription')?.value || 
                                '修正エンジン対応配置：ガイスタールール準拠';
            const quantumDesc = '確率的量子推定器による敵コマの善玉/悪玉確率推定';
            const rewardDesc = 'バランス型報酬関数：捕獲・脱出・戦略的行動を総合評価';
            const qmapDesc = 'DQNによるQ値学習：深層強化学習で価値関数を近似';
            const actionDesc = 'ε-greedy戦略：探索と活用のバランスを動的調整';

            const code = `# ============================================
# Quantum Battle System - Auto-Generated Code
# ============================================
# 学習方法: ${config.learningMethod === 'reinforcement' ? '強化学習' : '教師あり学習'}
# 生成日時: ${new Date().toLocaleString('ja-JP')}
#
# ===== AI設計説明 =====
# 
# 【モジュール1: 初期配置戦略】
${placementDesc.split('\n').map(line => '# ' + line).join('\n')}
# 
# 【モジュール2: 量子推定システム】  
${quantumDesc.split('\n').map(line => '# ' + line).join('\n')}
# 
# 【モジュール3: 報酬戦略】
${rewardDesc.split('\n').map(line => '# ' + line).join('\n')}
# 
# 【モジュール4: Q値学習方式】
${qmapDesc.split('\n').map(line => '# ' + line).join('\n')}
# 
# 【モジュール5: 行動選択戦略】
${actionDesc.split('\n').map(line => '# ' + line).join('\n')}
# 
# ============================================

import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
import sys
import os
from pathlib import Path

# 修正されたゲームエンジンのインポート
sys.path.append(str(Path(__file__).parent))
sys.path.append(str(Path(__file__).parent / "src"))
from src.qugeister_competitive.debug_game_viewer import DebugGeisterGame
from src.qugeister_competitive.ai_base import BaseAI

# ===== ゲームエンジン初期化（修正版） =====
game_engine = DebugGeisterGame()

# ===== 学習方法の設定 =====
learning_config = {
    'method': '${config.learningMethod}',
    'algorithm': '${config.learningMethod === 'reinforcement' ? config.qmap : 'supervised'}',
}

# ===== モジュール設定 =====
module_config = {
    # モジュール1: 初期配置（修正されたエンジン対応 - プレイヤーA下側配置）
    'placement': {
        'type': '${config.placement}',
        'player_a_bottom': True,    # プレイヤーAは下側（y=4,5）に配置
        'player_b_top': True,       # プレイヤーBは上側（y=0,1）に配置
        'my_pieces_only': np.array([
${config.board.slice(4, 6).map(row => '            ' + JSON.stringify(row.map(val => (val === 1 || val === -1) ? val : 0))).join(',\n')}
        ]),
        'escape_positions': {
            'player_a': [(0, 0), (5, 0)],  # A脱出口：相手陣地（上側角）
            'player_b': [(0, 5), (5, 5)]   # B脱出口：相手陣地（下側角）
        },
        'coordinate_system': 'corrected',  # 修正された座標系
        'opponent_unknown': True,          # 相手の駒配置は完全に未知
        'rule_compliant': True            # ガイスタールール準拠
    },
    
    # モジュール2: 敵駒推定（CQCNN）
    'quantum': {
        'n_qubits': ${config.qubits},
        'n_layers': ${config.layers},
        'embedding_type': '${config.embedding}',
        'entanglement': '${config.entanglement}',
        'total_params': ${config.qubits * config.layers * 3}
    },
    
    # モジュール3: 報酬関数（修正されたルール対応）
    'reward': {
        'strategy': '${config.reward}',
        'capture_good_reward': ${config.reward === 'aggressive' ? 20 : config.reward === 'defensive' ? 5 : 10},
        'capture_bad_penalty': -5,        # 相手の悪玉を取ることはマイナス
        'escape_reward': ${config.reward === 'escape' ? 100 : config.reward === 'defensive' ? 40 : 50},
        'captured_good_penalty': ${config.reward === 'defensive' ? -30 : -20},  # 善玉を取られる
        'captured_bad_reward': 10,        # 悪玉を取らせる（戦略的）
        'win_condition_rewards': {
            'escape_win': 100,            # 脱出勝利
            'eliminate_all_good': 100,    # 相手善玉全取得
            'eliminate_all_bad': 100      # 相手悪玉全取らせ
        },
        'position_rewards': {
            'advance_toward_escape': 2,   # 脱出口への前進
            'center_control': 1,          # 中央制御
            'opponent_territory': 3       # 相手陣地への侵入
        }
    },
    
    # モジュール4: Q値計算（修正されたエンジン対応）
    'qmap': {
        'method': '${config.qmap}',
        'state_dim': ${config.stateChannels ? config.stateChannels * 36 : 252},  # 6x6x${config.stateChannels || 7}チャンネル
        'action_dim': 5,         # 4方向 + 脱出
        'selected_channels': ${config.stateChannels || 7},
        'state_channels': {
            'my_good_pieces': 1,     # 自分の善玉位置
            'my_bad_pieces': 1,      # 自分の悪玉位置  
            'opponent_pieces': 1,    # 相手の駒位置（種類不明）
            'known_opponent_good': 1, # 確認済み相手善玉
            'known_opponent_bad': 1,  # 確認済み相手悪玉
            'legal_moves': 1,        # 移動可能位置
            'escape_positions': 1,   # 脱出可能位置
            ${config.stateChannels >= 12 ? `
            'opponent_escape_routes': 1,  # 相手の脱出経路
            'attack_positions': 1,        # 攻撃可能位置
            'danger_zones': 1,            # 危険地帯
            'territory_control': 1,       # 制圧領域
            'escape_blocking': 1,         # 脱出阻止位置
            ` : ''}
            ${config.stateChannels >= 16 ? `
            'piece_value_map': 1,         # 駒価値マップ
            'movement_history': 1,        # 移動履歴
            'turn_phase': 1,              # ゲーム段階
            'opponent_intention': 1,      # 相手意図推定
            ` : ''}
        },
        'legal_moves_only': True, # 合法手のみ考慮
        'game_engine': 'DebugGeisterGame',  # 使用するゲームエンジン
        'move_validation': True   # 手の有効性検証
    },
    
    # モジュール5: 行動選択
    'action': {
        'strategy': '${config.action}',
        'epsilon': ${config.action === 'epsilon' ? hyperparams.epsilon : 'None'},
        'temperature': ${config.action === 'boltzmann' ? '1.0' : 'None'}
    }
}

# ===== ハイパーパラメータ =====
hyperparameters = {
    # 基本学習設定
    'learning_rate': ${hyperparams.learningRate},
    'batch_size': ${document.getElementById('batchSize').value},
    'epochs': ${document.getElementById('epochs').value},
    'validation_split': ${hyperparams.validation},
    
    # 最適化設定
    'optimizer': '${document.getElementById('optimizer').value}',
    'scheduler': '${document.getElementById('scheduler').value}',
    'dropout_rate': ${hyperparams.dropout},
    'l2_regularization': ${hyperparams.l2Reg},
    ${config.learningMethod === 'reinforcement' ? `
    # 強化学習パラメータ
    'epsilon': ${hyperparams.epsilon},
    'epsilon_decay': ${hyperparams.epsilonDecay},
    'epsilon_min': 0.01,
    'gamma': ${hyperparams.gamma},
    'replay_buffer_size': ${document.getElementById('replayBuffer').value},
    'target_update_freq': 100,` : `
    # 教師あり学習パラメータ
    'dataset_path': '${document.getElementById('datasetPath').value || 'path/to/dataset.csv'}',
    'augmentation': '${document.getElementById('augmentation').value}',
    'class_weight': '${document.getElementById('classWeight').value}',
    'loss_function': '${document.getElementById('lossFunction').value}',`}
}

# ===== モデル構築（修正されたエンジン対応） =====
class CorrectedQuantumBattleAI(BaseAI, nn.Module):
    def __init__(self, name="QuantumBattleAI", player_id="B"):
        BaseAI.__init__(self, name, player_id)
        nn.Module.__init__(self)
        self.config = module_config
        
        # CQCNNエンコーダ
        self.quantum_encoder = self._build_quantum_encoder()
        
        # 古典的デコーダ（脱出アクション対応）
        # 古典的デコーダ（軽量化版）
        self.classical_decoder = nn.Sequential(
            nn.Linear(self.config['quantum']['n_qubits'], 32),
            nn.ReLU(),
            nn.Linear(32, 5)  # 4方向 + 脱出アクション（軽量化）
        )
    
    def get_move(self, game_state, legal_moves):
        """修正されたエンジン用の手選択（BaseAI抽象メソッド実装）"""
        if not legal_moves:
            return None
        
        # 脱出可能手を最優先
        escape_moves = [move for move in legal_moves if isinstance(move[1], str) and move[1] == "ESCAPE"]
        if escape_moves and self.config['reward']['strategy'] == 'escape':
            return escape_moves[0]
        
        # 量子ネットワークで評価
        state_tensor = self._encode_game_state(game_state)
        q_values = self.forward(state_tensor)
        
        # 合法手のみから選択
        best_move = None
        best_value = float('-inf')
        
        for move in legal_moves:
            move_idx = self._move_to_index(move)
            if move_idx < len(q_values) and q_values[move_idx] > best_value:
                best_value = q_values[move_idx]
                best_move = move
        
        return best_move if best_move else legal_moves[0]
    
    def choose_action(self, game_state):
        """human_vs_ai_battle.py用のアクション選択"""
        legal_moves = game_state.get_legal_moves(self.player_id)
        return self.get_move(game_state, legal_moves)
    
    def _build_quantum_encoder(self):
        # 量子回路の構築
        from pennylane import numpy as qnp
        import pennylane as qml
        
        n_qubits = self.config['quantum']['n_qubits']
        n_layers = self.config['quantum']['n_layers']
        
        # lightning.qubitが使えない場合はdefault.qubitを使用
        try:
            dev = qml.device('lightning.qubit', wires=n_qubits)
        except (ImportError, Exception):
            dev = qml.device('default.qubit', wires=n_qubits)
        
        @qml.qnode(dev)
        def quantum_circuit(inputs, weights):
            # データエンコーディング
            for i in range(n_qubits):
                if self.config['quantum']['embedding_type'] == 'angle':
                    qml.RY(inputs[i], wires=i)
                else:
                    qml.RX(inputs[i], wires=i)
            
            # パラメータ化量子回路
            for l in range(n_layers):
                # 回転層
                for i in range(n_qubits):
                    qml.RY(weights[l][i][0], wires=i)
                    qml.RZ(weights[l][i][1], wires=i)
                
                # エンタングルメント層
                if self.config['quantum']['entanglement'] == 'linear':
                    for i in range(n_qubits - 1):
                        qml.CNOT(wires=[i, i+1])
                elif self.config['quantum']['entanglement'] == 'full':
                    for i in range(n_qubits):
                        for j in range(i+1, n_qubits):
                            qml.CZ(wires=[i, j])
            
            # 測定
            return [qml.expval(qml.PauliZ(i)) for i in range(n_qubits)]
        
        return quantum_circuit
    
    def _encode_game_state(self, game_state):
        """ゲーム状態を7チャンネルテンソルにエンコード"""
        import torch
        import numpy as np
        
        # 6x6x7のテンソルを初期化
        state_tensor = torch.zeros(7, 6, 6)
        
        # チャンネル0: 自分の善玉位置
        my_pieces = game_state.player_a_pieces if self.player_id == "A" else game_state.player_b_pieces
        for (x, y), piece_type in my_pieces.items():
            if piece_type == "good":
                state_tensor[0, y, x] = 1
        
        # チャンネル1: 自分の悪玉位置
        for (x, y), piece_type in my_pieces.items():
            if piece_type == "bad":
                state_tensor[1, y, x] = 1
        
        # チャンネル2: 相手の駒位置（種類不明）
        opponent_pieces = game_state.player_b_pieces if self.player_id == "A" else game_state.player_a_pieces
        for (x, y), piece_type in opponent_pieces.items():
            state_tensor[2, y, x] = 1
        
        # チャンネル3&4: 確認済み相手善玉・悪玉（簡易実装）
        # 実際の実装では、過去の捕獲情報から推定
        
        # チャンネル5: 移動可能位置
        legal_moves = game_state.get_legal_moves(self.player_id)
        for move in legal_moves:
            if len(move) == 2 and isinstance(move[1], tuple):
                from_pos, to_pos = move
                x, y = to_pos
                state_tensor[5, y, x] = 1
        
        # チャンネル6: 脱出可能位置
        escape_positions = self.config['placement']['escape_positions']
        if self.player_id in escape_positions:
            for x, y in escape_positions[self.player_id]:
                state_tensor[6, y, x] = 1
        
        return state_tensor.flatten()  # 252次元に平坦化
    
    def _move_to_index(self, move):
        """移動を行動インデックスに変換"""
        if len(move) == 2 and move[1] == "ESCAPE":
            return 4  # 脱出アクション
        
        # 4方向移動を0-3にマップ
        if len(move) == 2:
            from_pos, to_pos = move
            dx = to_pos[0] - from_pos[0]
            dy = to_pos[1] - from_pos[1]
            
            if dx == 0 and dy == -1: return 0  # 上
            elif dx == 1 and dy == 0: return 1  # 右
            elif dx == 0 and dy == 1: return 2  # 下
            elif dx == -1 and dy == 0: return 3  # 左
        
        return 0  # デフォルト
    
    def _distribute_channels_to_qubits(self, x):
        """7チャンネル（252次元）を量子ビット数に均等分散"""
        import torch
        import numpy as np
        
        n_qubits = self.config['quantum']['n_qubits']
        
        # 252次元を7チャンネル × 36次元に分割
        channels = x.view(7, 36)  # [7チャンネル, 6×6=36次元]
        
        # 各チャンネルから代表値を抽出
        channel_features = []
        for ch in range(7):
            channel_data = channels[ch]  # 36次元
            
            # 各チャンネルから重要な特徴を抽出
            mean_val = channel_data.mean().item()          # 平均値
            max_val = channel_data.max().item()            # 最大値  
            nonzero_count = (channel_data > 0).sum().item() / 36.0  # 非ゼロ率
            center_val = channel_data[15:21].mean().item()  # 中央部の平均（戦略的重要エリア）
            
            channel_features.extend([mean_val, max_val, nonzero_count, center_val])
        
        # 7チャンネル × 4特徴 = 28次元の特徴ベクトル
        feature_vector = torch.tensor(channel_features, dtype=torch.float32)
        
        # 量子ビット数に合わせて調整（7チャンネル強制均等分散）
        if n_qubits >= 7:
            # 量子ビットが7以上：各チャンネルから最低1つ選択
            selections = []
            base_per_channel = n_qubits // 7
            extra = n_qubits % 7
            
            for ch_idx in range(7):
                count = base_per_channel + (1 if ch_idx < extra else 0)
                for i in range(count):
                    feat_idx = i % 4  # 特徴をローテーション (平均→最大→非ゼロ率→中央)
                    selections.append(ch_idx * 4 + feat_idx)
            
            quantum_input = feature_vector[selections]
        else:
            # 量子ビットが7未満：重要度順に7チャンネルから選択
            priorities = [0, 1, 2, 5, 6, 3, 4]  # 自分善玉→自分悪玉→敵駒→合法手→脱出→確認済み
            selections = []
            for i in range(n_qubits):
                ch_idx = priorities[i]
                feat_idx = 0  # 最重要特徴（平均値）
                selections.append(ch_idx * 4 + feat_idx)
            
            quantum_input = feature_vector[selections]
        
        # 量子回路用に正規化（0-π範囲）
        quantum_input = torch.tanh(quantum_input) * np.pi / 2
        
        return quantum_input
    
    def forward(self, x):
        # 7チャンネル均等分散量子エンコーディング
        weights = torch.randn(self.config['quantum']['n_layers'], self.config['quantum']['n_qubits'], 2) * 0.1
        quantum_input = self._distribute_channels_to_qubits(x)
        quantum_features = torch.tensor(self.quantum_encoder(quantum_input, weights))
        
        # 古典的処理
        output = self.classical_decoder(quantum_features)
        
        return output

# ===== 学習プロセス =====
def train_model(model, config, hyperparameters):
    # オプティマイザ設定
    if hyperparameters['optimizer'] == 'adam':
        optimizer = optim.Adam(
            model.parameters(), 
            lr=hyperparameters['learning_rate'],
            weight_decay=hyperparameters['l2_regularization']
        )
    elif hyperparameters['optimizer'] == 'sgd':
        optimizer = optim.SGD(
            model.parameters(),
            lr=hyperparameters['learning_rate'],
            momentum=0.9,
            weight_decay=hyperparameters['l2_regularization']
        )
    
    # スケジューラ設定
    if hyperparameters['scheduler'] == 'cosine':
        scheduler = optim.lr_scheduler.CosineAnnealingLR(
            optimizer, T_max=hyperparameters['epochs']
        )
    elif hyperparameters['scheduler'] == 'step':
        scheduler = optim.lr_scheduler.StepLR(
            optimizer, step_size=30, gamma=0.1
        )
    else:
        scheduler = None
    
    ${config.learningMethod === 'reinforcement' ? `# 強化学習ループ
    from collections import deque
    import random
    
    # リプレイバッファ
    replay_buffer = deque(maxlen=hyperparameters['replay_buffer_size'])
    
    # ε-greedy パラメータ
    epsilon = hyperparameters['epsilon']
    
    for episode in range(hyperparameters['epochs']):
        state = system.reset()
        total_reward = 0
        done = False
        
        while not done:
            # 行動選択
            if random.random() < epsilon:
                action = random.choice(range(4))
            else:
                with torch.no_grad():
                    q_values = model(state)
                    action = q_values.argmax().item()
            
            # 環境との相互作用
            next_state, reward, done = system.step(action)
            
            # リプレイバッファに保存
            replay_buffer.append((state, action, reward, next_state, done))
            
            # ミニバッチ学習
            if len(replay_buffer) >= hyperparameters['batch_size']:
                batch = random.sample(replay_buffer, hyperparameters['batch_size'])
                states, actions, rewards, next_states, dones = zip(*batch)
                
                # Q値の計算と更新
                current_q = model(torch.tensor(states))
                next_q = model(torch.tensor(next_states))
                target_q = rewards + hyperparameters['gamma'] * next_q.max(1)[0] * (1 - dones)
                
                loss = nn.MSELoss()(current_q.gather(1, actions), target_q)
                
                optimizer.zero_grad()
                loss.backward()
                optimizer.step()
            
            state = next_state
            total_reward += reward
        
        # εの減衰
        epsilon = max(0.01, epsilon * hyperparameters['epsilon_decay'])
        
        # スケジューラ更新
        if scheduler:
            scheduler.step()
        
        print(f"Episode {episode}: Total Reward = {total_reward:.2f}, ε = {epsilon:.4f}")` : `# 教師あり学習ループ
    from torch.utils.data import DataLoader, TensorDataset
    import pandas as pd
    
    # データセット読み込み
    data = pd.read_csv(hyperparameters['dataset_path'])
    X_train = torch.tensor(data.iloc[:, :-1].values, dtype=torch.float32)
    y_train = torch.tensor(data.iloc[:, -1].values, dtype=torch.long)
    
    # データローダー作成
    dataset = TensorDataset(X_train, y_train)
    train_size = int((1 - hyperparameters['validation_split']) * len(dataset))
    val_size = len(dataset) - train_size
    train_dataset, val_dataset = torch.utils.data.random_split(dataset, [train_size, val_size])
    
    train_loader = DataLoader(train_dataset, batch_size=hyperparameters['batch_size'], shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=hyperparameters['batch_size'])
    
    # 損失関数
    if hyperparameters['loss_function'] == 'cross_entropy':
        criterion = nn.CrossEntropyLoss()
    elif hyperparameters['loss_function'] == 'mse':
        criterion = nn.MSELoss()
    
    # 学習ループ
    for epoch in range(hyperparameters['epochs']):
        # 訓練フェーズ
        model.train()
        train_loss = 0
        train_correct = 0
        
        for batch_x, batch_y in train_loader:
            optimizer.zero_grad()
            outputs = model(batch_x)
            loss = criterion(outputs, batch_y)
            loss.backward()
            optimizer.step()
            
            train_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            train_correct += (predicted == batch_y).sum().item()
        
        # 検証フェーズ
        model.eval()
        val_loss = 0
        val_correct = 0
        
        with torch.no_grad():
            for batch_x, batch_y in val_loader:
                outputs = model(batch_x)
                loss = criterion(outputs, batch_y)
                
                val_loss += loss.item()
                _, predicted = torch.max(outputs.data, 1)
                val_correct += (predicted == batch_y).sum().item()
        
        # スケジューラ更新
        if scheduler:
            scheduler.step()
        
        print(f"Epoch {epoch}/{hyperparameters['epochs']}")
        print(f"Train Loss: {train_loss/len(train_loader):.4f}, Train Acc: {train_correct/train_size:.4f}")
        print(f"Val Loss: {val_loss/len(val_loader):.4f}, Val Acc: {val_correct/val_size:.4f}")`}
    
    return model

# ===== メイン実行 =====
if __name__ == "__main__":
    # モデル初期化
    model = CorrectedQuantumBattleAI()
    
    print("========================================")
    print("Quantum Battle System - Training Started")
    print("========================================")
    print("学習方法: 強化学習")
    print(f"量子ビット数: {module_config['quantum']['n_qubits']}")
    print(f"レイヤー数: {module_config['quantum']['n_layers']}")
    print(f"総パラメータ数: {sum(p.numel() for p in model.parameters())}")
    print("========================================")
    
    # 学習実行
    trained_model = train_model(model, module_config, hyperparameters)
    
    # モデル保存
    torch.save({
        'model_state_dict': trained_model.state_dict(),
        'module_config': module_config,
        'hyperparameters': hyperparameters,
        'learning_method': learning_config
    }, 'quantum_battle_model.pth')
    
    print("\\n========================================")
    print("Training Complete! Model saved as 'quantum_battle_model.pth'")
    print("========================================")`;

            document.getElementById('generatedCode').textContent = code;
            document.getElementById('codeOutput').style.display = 'block';
            
            // 設定をローカルストレージに保存（Playground連携用）
            const playgroundConfig = {
                source: '3step_system',
                timestamp: new Date().toISOString(),
                config: config,
                hyperparameters: {
                    batchSize: batchSize,
                    epochs: epochs,
                    optimizer: optimizer,
                    scheduler: scheduler,
                    replayBuffer: replayBuffer
                },
                descriptions: {
                    placement: placementDesc,
                    quantum: quantumDesc,
                    reward: rewardDesc,
                    qmap: qmapDesc,
                    action: actionDesc
                }
            };
            localStorage.setItem('3step_config', JSON.stringify(playgroundConfig));
            
            // Playgroundへ移動ボタンを表示
            showPlaygroundButton();
            
            // スクロール
            document.getElementById('codeOutput').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Playgroundへ移動ボタンを表示
        function showPlaygroundButton() {
            const existingBtn = document.getElementById('goToPlayground');
            if (!existingBtn) {
                const btn = document.createElement('button');
                btn.id = 'goToPlayground';
                btn.className = 'btn btn-primary';
                btn.style.marginTop = '20px';
                btn.innerHTML = '🎨 Playgroundで詳細設計 →';
                btn.onclick = () => {
                    window.open('quantum_ai_playground.html', '_blank');
                };
                document.getElementById('codeOutput').appendChild(btn);
            }
        }

        // コードコピー
        function copyCode() {
            const code = document.getElementById('generatedCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                alert('コードをクリップボードにコピーしました！');
            });
        }

    </script>
    <!-- <script src="scripts.js"></script> 外部スクリプト不要 -->
</body>
</html>